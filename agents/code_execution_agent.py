import ast
import textwrap
import pandas as pd
import re
import math
import statistics
import collections
import numpy as np
from collections import Counter, defaultdict


class ExecutionAgent:
    def __init__(self):
        """Initialize execution agent with a safe execution environment."""
        self.safe_builtins = {
            "True": True,
            "False": False,
            "None": None,
            "sum": sum,
            "len": len,
            "max": max,
            "min": min,
            "range": range,
            "list": list,
            "dict": dict,
            "set": set,
            "sorted": sorted,
            "any": any,
            "all": all,
            "abs": abs,
            "float": float,
            "int": int,
            "next": next,
            "math": math,
            "statistics": statistics,
            "collections": collections,
            "Counter": Counter,
            "defaultdict": defaultdict,
            "np": np,  # Numpy support
            "pd": pd,  # Pandas support
            "str": str,
            "print": print,
            "__import__": __import__,  # ‚úÖ Allow explicit imports
            "filter": filter,  # ‚úÖ Allow filter function
            "eval": eval,
        }

    def auto_fix_syntax(self, snippet: str) -> str:
        """Attempts to auto-fix minor syntax errors in the generated code."""
        snippet = snippet.replace("‚Äò", "'").replace("‚Äô", "'").replace("‚Äú", '"').replace("‚Äù", '"')

        # Ensure function body if missing
        if re.search(r"def\s+answer\s*\(.*\):\s*$", snippet):
            snippet += "\n    pass"  # Add a placeholder body
        return snippet

    def clean_code(self, snippet: str) -> str:
        """
        Cleans up the generated code by:
        - Removing unnecessary 'python' keywords.
        - Fixing minor syntax issues.
        """
        snippet = snippet.strip("` \n\r")

        # üõë **Fix issue where 'python' is included in generated code**
        snippet = re.sub(r"^\s*python\s+", "", snippet)  # Removes 'python' at the start of the code

        # Ensure function body if missing
        if re.search(r"def\s+answer\s*\(.*\):\s*$", snippet):
            snippet += "\n    pass"  # Add a placeholder body

        return snippet

    def execute_code(self, response_code: str, data):
        """
        Executes the Python code generated by the LLM.
        - Parses the code safely.
        - Looks for 'answer(data)' function.
        - Runs 'answer(data)' in a sandboxed environment.
        - Returns a concise result.
        """

        # 1Ô∏è‚É£ **Sanitize the generated code**
        cleaned_code = self.clean_code(response_code)

        print("\nüîç DEBUG: Generated Code AFTER Cleaning:\n", cleaned_code, "\n")  # Debug log


        # ‚ùå Prevent executing non-Python strings like "python"
        if "python" in cleaned_code.lower():
            return "__INFERENCE_ERROR__: Invalid code. Non-Python command detected."

        try:
            parsed = ast.parse(textwrap.dedent(cleaned_code))
        except SyntaxError as e:
            # Log the invalid code for debugging
            print(f"‚ùå Syntax Error in Code: {cleaned_code}\n")
            print(f"üîç DEBUG: Syntax Error Details: {e}")
            return f"__INFERENCE_ERROR__: Invalid syntax after fix: {e}"

        # 2Ô∏è‚É£ **Setup execution environment**
        exec_globals = {"__builtins__": self.safe_builtins}  # Restrict execution
        exec_locals = {}

        # 3Ô∏è‚É£ **Compile and execute the function**
        try:
            compiled = compile(parsed, filename="<string>", mode="exec")
            exec(compiled, exec_globals, exec_locals)  # Execute safely
        except Exception as e:
            return f"__INFERENCE_ERROR__: Could not execute code: {e}"

        # 4Ô∏è‚É£ **Find the answer() function**
        if "answer" not in exec_locals:
            return "__INFERENCE_ERROR__: No 'answer' function defined."

        answer_func = exec_locals["answer"]

        # 5Ô∏è‚É£ **Call the generated function with the dataset**
        try:
            result = answer_func(data)

            # üõ† **NEW: Handle Pandas Timestamp Issues**
            if isinstance(result, pd.Timestamp):
                result = result.strftime("%Y-%m-%d %H:%M:%S")  # Convert to string format

            elif isinstance(result, list):  # If the result is a list, handle Timestamps inside
                result = [item.strftime("%Y-%m-%d %H:%M:%S") if isinstance(item, pd.Timestamp) else item for item in
                          result]

        except Exception as e:
            return f"__INFERENCE_ERROR__: Error calling answer(data): {e}"

        # 6Ô∏è‚É£ **Format the output for readability**
        return str(result)  # Ensure everything is a string before returning